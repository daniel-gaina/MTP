\documentclass{article}
\usepackage[left=1.5cm, right=1.5cm, top=2cm]{geometry}
\input{env}
 %*******************************************************
 \usepackage{booktabs} % For formal tables
%************************ packages *********************************
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[inline]{enumitem}
\usepackage[latin1]{inputenc}
\usepackage{xy}
\xyoption{all}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage[colorlinks=true,linkcolor=green]{hyperref}
\usepackage[skip=0pt]{caption}

%\usepackage{mathabx}

%************************ shortcuts ********************************
\newcommand{\PL}{{\mathsf{PL}}}
\newcommand{\HPL}{{\mathsf{HPL}}}
\newcommand{\HPLQ}{{\mathsf{HPLQ}}}

\newcommand{\FOL}{{\mathsf{FOL}}}

\newcommand{\Sig}{\mathsf{Sig}}
\newcommand{\Mod}{\mathsf{Mod}}
\newcommand{\Sen}{\mathsf{Sen}}

\newcommand{\Nom}{\mathsf{Nom}}
\newcommand{\Prop}{\mathsf{Prop}}
%*******************************************************
%*******************************************************
\newcommand{\X}{\mathtt{X}}
\newcommand{\Y}{\mathtt{Y}}
\newcommand{\Z}{\mathtt{Z}}
\newcommand{\Q}{\mathtt{Q}}
\newcommand{\B}{\mathtt{B}}
\newcommand{\A}{\mathtt{A}}
\newcommand{\C}{\mathtt{C}}
\newcommand{\D}{\mathtt{D}}
\newcommand{\E}{\mathtt{E}}
\newcommand{\F}{\mathtt{F}}
\newcommand{\I}{\mathtt{I}}
\newcommand{\J}{\mathtt{J}}
\newcommand{\K}{\mathtt{K}}
\renewcommand{\L}{\mathtt{L}}
\newcommand{\N}{{\mathtt{N}}}
\newcommand{\M}{{\mathtt{M}}}
\renewcommand{\P}{\mathtt{P}}
\renewcommand{\S}{\mathtt{S}}
%*******************************************************
\renewcommand{\a}{{\mathtt{a}}}
\renewcommand{\b}{{\mathtt{b}}}
\newcommand{\s}{{\mathtt{s}}}
\newcommand{\ari}{{\mathsf{ar}}}
\newcommand{\nom}{{\mathsf{n}}}
\newcommand{\pc}{{\mathtt{pc}}}
\newcommand{\pid}{{\mathtt{pid}}}
\newcommand{\sq}{{\mathtt{sq}}}
\newcommand{\re}{{\mathtt{re}}}
\newcommand{\wt}{{\mathtt{wt}}}
\newcommand{\cs}{{\mathtt{cs}}}
\newcommand{\var}{{\mathtt{var}\ }}
\newcommand{\vars}{{\mathtt{vars}\ }}
\newcommand{\op}{{\mathtt{op}\ }}
\newcommand{\ops}{{\mathtt{ops}\ }}
%*******************************************************
\newcommand{\LIST}{{\mathtt{LIST}}}
\newcommand{\QLOCK}{{\mathtt{QLOCK}}}
\newcommand{\ELT}{{\mathtt{ELT}}}
\newcommand{\BOOL}{{\mathtt{BOOL}}}
\newcommand{\List}{{\mathtt{List}}}
\newcommand{\Elt}{{\mathtt{Elt}}}
\newcommand{\TRIV}{{\mathtt{TRIV}}}
\newcommand{\BUFFER}{{\mathtt{BUFFER}}}
\newcommand{\Pid}{{\mathtt{Pid}}}
\newcommand{\Sys}{{\mathtt{Sys}}}
\newcommand{\Agent}{{\mathtt{Agent}}}
\newcommand{\Sequence}{{\mathtt{Sequence}}}
\newcommand{\Label}{{\mathtt{Label}}}

\newcommand{\Top}{{\mathtt{top}}}
\newcommand{\false}{{\mathtt{false}}}
\newcommand{\true}{{\mathtt{true}}}
\newcommand{\If}{{\ \mathtt{if}\ }}
\newcommand{\In}{{\ \mathtt{in}\ }}
\newcommand{\err}{{\mathtt{err}}}
\newcommand{\Empty}{{\mathtt{empty}}}
\newcommand{\fifo}{{\mathtt{fifo}}}
\newcommand{\lifo}{{\mathtt{lifo}}}
\newcommand{\Read}{{\mathtt{read}}}
\newcommand{\init}{{\mathtt{init}}}
\newcommand{\Next}{{\mathtt{next}}}
\newcommand{\del}{{\mathtt{del}}}
\newcommand{\shift}{{\mathtt{shift}}}
\newcommand{\lt}{{\mathtt{l}}}
\newcommand{\e}{{\mathtt{e}}}
\newcommand{\PR}{{\mathsf{PR}}}
\newcommand{\want}{{\mathtt{want}}}
\newcommand{\try}{{\mathtt{try}}}
\newcommand{\exit}{{\mathtt{exit}}}
\newcommand{\get}{{\mathtt{get}}}
%*******************************************************
\usepackage{scalerel}

\newcommand{\bbsemicolon}{%
  \scalerel*{%
    \hbox{\usefont{U}{bbold}{m}{n} ;}%
  }{;}%
}

\newcommand{\comp}{\mathbin{\bbsemicolon}}
%*******************************************************
\newcommand{\modelsm}{\mathrel{\models\!\!\!|}}
\newcommand{\vdashv}{\mathrel{\vdash\!\!\dashv}}
\newcommand{\red}{\!\upharpoonright\!\!}
\newcommand{\ul}{\!\!\_}
\newcommand{\ur}{\_\!\!}
%*********sentence building operators********************
\newcommand{\At}[1]{\mathsf{at}_{#1}\, }
\newcommand{\at}[1]{@_{#1}\,}
\newcommand{\nec}[1]{[#1]}
\newcommand{\store}[1]{{\downarrow}#1\,{\cdot}\,}
\newcommand{\Forall}[1]{\forall #1\,{\cdot}\,}
\newcommand{\Exists}[1]{\exists #1\,{\cdot}\,}
\newcommand{\pos}[1]{{\langle}#1{\rangle}}
\renewcommand{\land}{\ \bigwedge\ }
%*******************proof rules**************************
\newcommand{\inferrule}[2]{$\displaystyle\frac{#1}{#2}$}
%********************************************************
%% entailment properties  ........................................

%**************Theorem environments********************************* 
\newtheorem{framework}{Framework}[section]
\newtheorem{assumption}{Assumption}
\newtheorem{notation}{Notation}
\newtheorem{remark}{Remark}[section]
\newtheorem{fact}{Fact}[section]
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
%**************Theorem environments********************************* 
% ***************************************************************

\newcommand{\minisec}[1]{%
  \par\addvspace{\smallskipamount}\noindent%
  \textit{#1}.\enspace%
}
%*******************************************************
\newcounter{nr}
%*******************************************************
\begin{document}
\section{Modeling}
We present the specification of a mutual exclusion protocol.
\subsection{Rigid data types}

\begin{example}[Labels]
 \begin{verbatim}
 
 spec! LABEL
 sort Label .
 ops re wt cs : -> Label [ctor].
 op _~_ : Label Label -> Bool [comm].
 var  L : Label .
 eq (re ~ wt) = false .
 eq (re ~ cs) = false .
 eq (wt ~ cs) = false .
---
 ceq true = false if re = wt .
 ceq true = false if re = cs .
 ceq true = false if wt = cs .
\end{verbatim}
\end{example}

\begin{example}[Process identifiers]
\begin{verbatim}

 spec* PID
 inc BOOL .
 sort Pid .
 op _~_ : Pid Pid -> Bool [comm].
 vars I J : Pid .
 eq I ~ I = true .
 ceq I = J if I ~ J [nonexec]. 
\end{verbatim}
\end{example}



\begin{example}[lists of process identifiers] 
\begin{verbatim}
 
 spec! SEQUENCE{X :: PID}
 sort Sequence .
 subsorts X$Pid < Sequence .
--- constructors 
 op empty : -> Sequence [ctor] .
 op _,_ : Sequence Sequence -> Sequence [ctor id: empty assoc].
 vars Q Q' : Sequence . var I : X$Pid .
--- 
 op top : Sequence -> X$Pid .
 eq top(empty) = empty .
 eq top(I,Q) = I .
---
 op get : Sequence -> Sequence .
 eq get(empty) = empty .
 eq get(I,Q) = Q .
---
 ceq true = false if Q,I,Q' := empty .
 ceq [lemma-top]: top(Q,I) = top(Q) if top(Q) :: X$Pid .

\end{verbatim}
\end{example}

\subsection{Nominals}

\begin{example}[Agents]
\begin{verbatim}
 
 spec* AGENT
 sort Agent
\end{verbatim}
\end{example}

\begin{example}[Nominals]
\begin{verbatim} 

 spec! NOMINAL{Y :: AGENT}
 sorts Sys.
 --- actions
 op init : -> Sys [ctor].
 ops want try exit : Sys Y$Agent -> Sys [ctor].
\end{verbatim}
\end{example}


\subsection{Flexible data types}
 \begin{example} [Mutual exclusion protocol] \
 
 \begin{itemize}[leftmargin=*] \tt
 \item[] spec* QLOCK\{X :: PID, Y :: AGENT\} 
 
 \item[] pr SEQUENCE\{X\} . pr NOMINAL\{Y\} . pr LABEL . 
 
 \item[] \tt --- observers

 \item[] $\op \pid : \to \X\$\Pid $ --- extract pid from agents 
 
 \item[] $\op \sq  : \to \Sequence $ --- gives the waiting queue for each state
 
 \item[] $\op \pc  : \to \Label $ --- indicates the label of each agent at a given state
\end{itemize}

\begin{itemize} [leftmargin=*] \tt
 \item[] --- variables 
 
 \item[] $\vars \S\ \S_1\ \S_2 : \Sys$
 
 \item[] $\vars \I\ \J\ \K : \X\$\Pid$
 
 \item[] $\vars \A\ \B\ \C : \Y\$\Agent$
 
 \item[] $\var \Q:\Sequence$
\end{itemize}
 
\begin{enumerate}[label=(\arabic*),ref=\arabic*, leftmargin=*] \tt
 
 \item[] --- restrictions ---
 
 \item \label{sen-1} $\Forall{\A,\S_1,\S_2}\at{\S_1}\at{\A}\pid=\at{\S_2} \at{\A} \pid$  --- pid depends only of the agent
 
 \item \label{sen-2} $\Forall{\A,\B,\S}\at{\S}\at{\A}\sq=\at{\S} \at{\B}\sq$ --- sq depends only of the current state
 
 \item[]  --- init ---
 
 \item \label{sen-3}$\Forall{\A} \at{\init} \at{\A} \pc= \re$

 \item \label{sen-4}$\at{\init}\sq=\Empty$ 
 
 \item[] --- want --- 

 \item \label{sen-5}$\Forall{\S,\A,\B} \at{\want(\S,\A)} \at{\B}  \pc=\wt \If \at{\S} \at{\A} \pc=\re \land \A=\B$
 
 \item \label{sen-6}$\Forall{\S,\A,\B} \at{\want(\S,\A)} \at{\B} \pc= \at{\S} \at{\B} \pc \If  \neg(\A = \B) $
 
 \item \label{sen-7}$\Forall{\S,\A,\B} \at{\want(\S,\A)} \at{\B}  \pc= \at{\S} \at{\B} \pc \If  \neg(\at{\A}\at{\S}\pc = \re)$
  
 \item \label{sen-8}$\Forall{\S,\A} \at{\want(\S,\A)}\sq = (\at{\S}\sq), (\at{\A} \pid) \If \at{\S} \at{\A} \pc=\re$

 \item \label{sen-9}$\Forall{\S,\A} \at{\want(\S,\A)}\sq = \at{\S}\sq \If \neg(\at{\S} \at{\A} \pc=\re)$  
 
 \item[] --- try ---

 \item \label{sen-10}$\Forall{\S,\A,\B} \at{\try(\S,\A)} \at{\B} \pc= \cs \If \at{\S} \at{\A} \pc = \wt \land (\at{\A}\pid), \Q := \at{\S} \sq \land \A = \B$
 
 \item \label{sen-11}$\Forall{\S,\A,\B} \at{\try(\S,\A)} \at{\B} \pc = \at{\S} \at{\B} \pc \If  \neg(\A=\B)$
 
 \item \label{sen-12}$\Forall{\S,\A,\B} \at{\try(\S,\A)} \at{\B} \pc=  \at{\S}  \at{\B} \pc \If \neg(\at{\S} \at{\A} \pc = \wt )$
  
 \item \label{sen-13}$\Forall{\S,\A,\B} \at{\B}\at{\try(\S,\A)}\pc= \at{\B} \at{\S} \pc \If  \neg(\Top(\at{\S}\sq) = \at{\A}\pid) $
  

 \item \label{sen-14}$\Forall{\S,\A} \at{\try(\S,\A)} \sq = \at{\S}\sq$  
 
 \item[] --- exit ---
 
 \item \label{sen-15}$\Forall{\S, \A,\B}  \at{\exit(\S,\A) }\at{\B}\pc = \re \text{ if } \at{\S} \at{\A} \pc = \cs \land \A = \B$
 
 \item \label{sen-16}$\Forall{\S, \A,\B}  \at{\exit(\S,\A) }\at{\B}\pc =  \at{\A }\at{\B}\pc \text{ if } \neg(\A = \B)$
 
 \item \label{sen-17}$\Forall{\S, \A,\B}  \at{\exit(\S,\A) }\at{\B}\pc =  \at{\A }\at{\B}\pc \text{ if } \neg(\at{\S} \at{\A} \pc = \cs)$
 
 \item \label{sen-18}$\Forall{\S,\A} \at{\exit(\S,\A)}\sq = \get (\at{\S}\sq) \text{ if } \at{\S}\at{\A} \pc = \cs$
 
  \item \label{sen-19}$\Forall{\S,\A} \at{\exit(\S,\A)}\sq = \at{\S}\sq \text{ if } \neg(\at{\S}\at{\A} \pc = \cs)$
  \setcounter{nr}{\value{enumi}}
 \end{enumerate}
 
 \end{example}

\section{Formal verification}

We are interested in proving formally 
 $\QLOCK\vdash\Forall{\S,\A}\Top(\at{\S}\sq)=\at{\A}\pid\text{ if } \at{\S}\at{\A}\pc=\cs$.
 
 ==============================================
   \begin{enumerate}[label=(\arabic*),ref=\arabic*,leftmargin=*] \tt
   \setcounter{enumi}{\value{nr}}
   \item [] spec $\QLOCK_I$
   
   \item [] pr QLOCK .
   
   \item [] op s : -> Sys .
   
   \setcounter{enumi}{\value{nr}}
   \item  $\Forall{\A}\Top(\at{\s}\sq)=\at{\A}\pid\text{ if } \at{\s}\at{\A}\pc=\cs$ [induction hypothesis].
   \setcounter{nr}{\value{enumi}}
   \end{enumerate}
  
  ==============================================
  \begin{enumerate}[label=(\arabic*),ref=\arabic*,leftmargin=*] \tt
   \setcounter{enumi}{\value{nr}} 
   
    \item[] spec $\QLOCK_{TC}$
    
    \item[] pr $\QLOCK_I$ .
    
    \item[] op a b : -> Y\$Agent . 
    
   \end{enumerate}
   
  ==============================================
 
 Apply induction on $\S$:
 
 \begin{proofcases}[itemsep=1ex]
 \item [$\init$] In this case,
 \begin{proofsteps}{25em}
  $\QLOCK\vdash\Forall{\A}\Top(\at{\init}\sq)=\at{\A}\pid\text{ if } \at{\init}\at{\A}\pc=\cs$ & \\
  
  $\QLOCK\vdash\Forall{\A}\Top(\at{\init}\sq)=\at{\A}\pid\text{ if } \re = \cs$ & by sentence (\ref{sen-3}) \\
  
  discharged & since $\QLOCK\vdash \true =\false \text{ if } \re=\cs$   
  
  
  \end{proofsteps} 
 \item [$\want$] \
    
   
   \begin{proofsteps}{30em}
    $\QLOCK_I\vdash \Forall{\A,\B}\Top(\at{\want(\s,\B)}\sq)=\at{\A}\pid\text{ if } \at{\want(\s,\B)}\at{\A}\pc=\cs$ & \\
    
    $\QLOCK_{TC}\vdash \Top(\at{\want(\s,\b)}\sq)=\at{\a}\pid\text{ if } \at{\want(\s,\b)}\at{\a}\pc=\cs$ & 
     
     \substeps{9}
      $\QLOCK_{TC}+\{\b=\a, \at{\s}\at{\b}\pc =\re \}\vdash \newline 
      \Top(\at{\want(\s,\b)}\sq)=\at{\a}\pid\text{ if } \at{\want(\s,\b)}\at{\a}\pc=\cs$ 
      & by case analysis  \\
      
      $\QLOCK_{TC}+\{\a=\b, \at{\s}\at{\b}\pc =\re \}\vdash \newline
      \Top(\at{\s}\sq,\at{\b}\pid)=\at{\b}\pid\text{ if } \wt =\cs$ & by rew  \\
      
      discharged & since $\QLOCK\vdash \true =\false \text{ if } \wt=\cs$   
     %\endsubsteps
   \end{proofsteps}   
   
 \item[$\try$]
 
 \item[$\exit$]
 \end{proofcases}
\end{document}