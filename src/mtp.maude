load metaInterpreter.maude
load aux_modules.maude
load grammar.maude
load file.maude

fmod COMMAND-SIGN is
 pr META-LEVEL .

 sort @Command@ @Token@ .

 op load_. : @Token@ -> @Command@ [ctor] .
endfm

fmod COMMAND-PROCESSING is
 pr PARSING-RESULT .
 pr META-MTP-SIGN .
 pr META-LEVEL .
 pr LEXICAL .

 vars PL PL' : ParameterDeclList .
 vars T T' T'' T1 T2 : Term .
 var  RP? : [ResultPair] .
 vars M M' M'' : Module .
 var  PR : ParsingRes .
 var  TyL : TypeList .
 var  DB : Database .
 var  TL : TermList .
 vars S S' : String .
 var  QIL : QidList .
 vars Q Q' : Qid .
 var  Srt : Sort .
 var  H : Header .

 op parseModule : Term Database -> ParsingRes .
 ceq parseModule('spec!_=_[T,T'], DB) = [ modName(H) -> [parseModule2(M, T'), parseModule2(M, T'), parseModule2(M, T')], ""]
  if H := parseHeader(T) /\
     M := emptyModule(H) .
 ceq parseModule('spec*_=_[T,T'], DB) = [ modName(H) -> [parseModule2(M, T'), parseModule2(M, T'), parseModule2(M, T')], ""]
  if H := parseHeader(T) /\
     M := emptyTheory(H) .

 op parseModule2 : Module Term -> Module .
 ceq parseModule2(M, '__[T, T']) = M''
  if M' := parseDef(M, T) /\
     M'' := parseModule2(M', T') .
 eq parseModule2(M, T) = parseDef(M, T) [owise] .

 op parseHeader : Term -> Header .
 ceq parseHeader('token[T]) = Q
  if Q := downQid(T) .
 ceq parseHeader('_`{_`}['token[T], T']) = Q{PL}
  if Q := downQid(T) /\
     PL := parsePL(T') .

 op modName : Header -> Qid .
 eq modName(Q) = Q .
 eq modName(Q{PL}) = Q .

 op parsePL : Term -> ParameterDeclList .
 ceq parsePL('_`,_[T, T']) = PL, PL'
  if PL := parsePL(T) /\
     PL' := parsePL(T') .
 ceq parsePL('_::_['token[T], 'token[T']]) = Q :: Q'
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op parseDef : Module Term -> Module .
 ceq parseDef(M, 'rigid`sort_['token[T]]) = M'
  if Srt := downQid(T) /\
     M' := addSorts(M, Srt) .
 ceq parseDef(M, 'nominal`pred_:__['token[T],T',T'']) = M''
  if Q := downQid(T) /\
     TyL := parseTypeList(M, T') /\
     M' := addOps(M, op Q : TyL -> 'Bool [metadata("nominal")] .) /\
     M'' := parseSen(M', T'') .
 eq parseDef(M, T) = M [owise print "owise"] . *** TODO!!!

 op parseSen : Module Term -> Module .
 eq parseSen(M, T) = M .

 op parseTypeList : Module Term -> TypeList .
 ceq parseTypeList(M, 'token[T]) = Q
  if Q := downQid(T) .
 eq parseTypeList(M, '_*_[TL]) = parseTypeList*(M, TL) .

 op parseTypeList* : Module TermList -> TypeList .
 eq parseTypeList*(M, empty) = nil .
 eq parseTypeList*(M, (T, TL)) = parseTypeList(M, T) parseTypeList*(M, TL) .

 op parseModule : String Database -> ParsingRes .
 ceq parseModule(S, DB) = PR
  if {T, Srt} := metaParse(GRAMMAR, tokenize(S), anyType) /\
     PR := parseModule(T, DB) [print T " - " Srt "\n" PR] .

 op isLoadComm : String -> Bool .
 ceq isLoadComm(S) = true
  if 'load QIL := tokenize(S) .
 eq isLoadComm(S) = false [owise] .

 op isExitComm : String -> Bool .
 ceq isExitComm(S) = true
  if 'exit := tokenize(S) .
 eq isExitComm(S) = false [owise] .

 op parseLoadComm : String -> String .
 ceq parseLoadComm(S) = string(Q')
  if Q Q' QIL := tokenize(S) .
endfm

mod MTP is
 pr (MAYBE * (op maybe to null)){Oid} .
 pr COMMAND-PROCESSING .
 inc META-INTERPRETER .
 inc STD-STREAM .
 pr DATABASE .
 inc FILE .

 vars Text Original Read Source STR : String .
 var  AtS : AttributeSet .
 vars FHIn FHOut MI : Oid .
 vars DB DB' : Database .
 var  QIL : QidList .
 var  Q : Qid .

 sort State .
 *** Initial state, metainterpreter is created
 op init : -> State [ctor] .
 *** Loading from standard database
 op load-std-db : -> State [ctor] .
 *** Loading grammar
 op load-grammar : -> State [ctor] .
 *** Waiting input from the user
 op idle : -> State [ctor] .
 *** Reading file
 op readFile : -> State [ctor] .
 *** Parsing Module
 op parseMod : -> State [ctor] .
 *** Waits for a wrote msg and returns to idle with getLine
 op print&idle : -> State [ctor] .

 *** Object and class definition
 op MTP : -> Cid .
 op mtp : -> Oid .

 *** Attributes
 op file:_ : Maybe{Oid} -> Attribute [ctor] .
 op load:_ : QidList -> Attribute [ctor gather (&)] .
 op db:_ : Database -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op out:_ : String -> Attribute [ctor] .
 op mi:_ : Oid -> Attribute [ctor] .

 *** Initial value for load
 op modList : -> QidList .
 eq modList = 'TRUTH-VALUE 'BOOL-OPS 'TRUTH 'BOOL 'NAT 'TRIV 'QID-LIST 'MTP-SIGN .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] : gotLine(mtp, stdin, Text)
    < mtp : MTP | out: Read, db: DB, state: idle, AtS >
 => < mtp : MTP | out: Read, db: DB, state: readFile, AtS >
    openFile(fileManager, mtp, Source, "r")
  if isLoadComm(Text) /\
     Source := parseLoadComm(Text) .

 ***                            ***
 ***          OPENFILE          ***
 ***                            ***

 rl [openedFile] : openedFile(mtp, fileManager, FHIn)
    < mtp : MTP | file: null, state: readFile, AtS >
 => < mtp : MTP | file: FHIn, state: readFile, AtS >
    getLine(FHIn, mtp) .

 rl [readingModule] : gotLine(mtp, FHIn, Text)
    < mtp : MTP | file: FHIn, out: Read, state: readFile, AtS >
 => if Text == ""
    then < mtp : MTP | file: FHIn, out: Read, state: readFile, AtS >
         closeFile(FHIn, mtp)
    else < mtp : MTP | file: FHIn, out: (Read + Text), state: readFile, AtS >
         getLine(FHIn, mtp)
    fi .

 crl [parseModuleOK] :
     < mtp : MTP | out: Read, db: DB, state: parseMod, AtS >
  => < mtp : MTP | out: "", db: DB', state: print&idle, AtS >
     write(stdout, mtp, STR + "\n")
  if [DB', STR] := parseModule(Read, DB) .

 *** TODO: parse error

 rl [print&idle] : wrote(mtp, stdout)
    < mtp : MTP | state: print&idle, AtS >
 => < mtp : MTP | state: idle, AtS >
    getLine(stdin, mtp, "MTP> ") .

 ***                               ***
 ***          CLOSE FILE           ***
 ***                               ***

 rl [closedFile] : closedFile(mtp, FHIn)
    < mtp : MTP | file: FHIn, state: readFile, AtS >
 => < mtp : MTP | file: null, state: parseMod, AtS > .

 ***                         ***
 ***          EXIT           ***
 ***                         ***

 crl [exit] : gotLine(mtp, stdin, Text)
     < mtp : MTP | AtS >
  => write(stdout, mtp, "Thanks for using MTP!\n")
  if isExitComm(Text) .

 ***                        ***
 ***          ERROR         ***
 ***                        ***

 crl [no-command] :
     gotLine(mtp, stdin, Text)
     < mtp : MTP | state: idle, AtS >
  => < mtp : MTP | state: print&idle, AtS >
     write(stdout, mtp, "The introduced command does not exit.\n")
  if not isExitComm(Text) /\
     not isLoadComm(Text) .

 ***                          ***
 ***          CREATE          ***
 ***      METAINTERPRETER     ***
 ***                          ***

 rl [init] :
    createdInterpreter(mtp, interpreterManager, MI)
    < mtp : MTP | state: init, load: Q QIL, AtS >
 => < mtp : MTP | state: load-std-db, mi: MI, load: QIL, AtS >
    insertModule(MI, mtp, upModule(Q, true)) .

 rl [load-predef] :
    insertedModule(mtp, MI)
    < mtp : MTP | state: load-std-db, load: Q QIL, AtS >
 => < mtp : MTP | state: load-std-db, load: QIL, AtS >
    insertModule(MI, mtp, upModule(Q, true)) .


 rl [load-preder-finished] :
    insertedModule(mtp, MI)
    < mtp : MTP | state: load-std-db, load: nil, AtS >
 => < mtp : MTP | state: load-grammar, AtS >
    insertModule(MI, mtp, GRAMMAR) .


 rl [load-grammar-finished] :
    insertedModule(mtp, MI)
    < mtp : MTP | state: load-grammar, AtS >
 => < mtp : MTP | state: idle, AtS >
    getLine(stdin, mtp, "Introduce command> ") .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < mtp : MTP | file: null, out: "", state: init, db: empty,
                     load: modList >
    createInterpreter(interpreterManager, mtp, none) .
endm

set print attribute on .

erew run .
