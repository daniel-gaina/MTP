load aux_modules.maude
load file.maude

fmod MTP-SIGN is
 pr META-LEVEL .

 sorts Spec @Sen@ @SenList@ @Token@ @Bubble@ @Arity@ @Def@ @DefSet@
       @NeTokenList@ .
 subsort @Sen@ < @SenList@ .
 subsort @Token@ < @Arity@ .
 subsort @Def@ < @DefSet@ .

 op __ : @SenList@ @SenList@ -> @SenList@ [ctor assoc] .
 op __ : @DefSet@ @DefSet@ -> @DefSet@ [ctor assoc comm] .

 op _*_ : @Arity@ @Arity@ -> @Arity@ [ctor assoc] .

 op spec_=_ : @Token@ @DefSet@ -> Spec [ctor] .

 op rigid`sort_ : @Token@ -> @Def@ [ctor] .
 op nominal`pred_:__ : @Token@ @Arity@ @SenList@ -> @Def@ [ctor] .

 op ._ : @Token@ -> @Sen@ [ctor] .
endfm

fmod META-MTP-SIGN is
 including AUX-MODULE-OPS .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'MTP-SIGN .)) .
endfm


fmod COMMAND-PROCESSING is
 pr META-MTP-SIGN .
 pr META-LEVEL .
 pr LEXICAL .

 vars T T' T'' T1 T2 : Term .
 var  RP? : [ResultPair] .
 vars M M' M'' : Module .
 var  TyL : TypeList .
 var  TL : TermList .
 vars S S' : String .
 var  QIL : QidList .
 vars Q Q' : Qid .
 var  Srt : Sort .

 op parseModName : Term -> Qid .
 eq parseModName(T) = downQid(T) .

 op parseModule : Term -> Module .
 ceq parseModule('spec_=_['token[T],T']) = parseModule2(M, T')
  if Q := downQid(T) /\
     M := emptyModule(Q) .

 op parseModule2 : Module Term -> Module .
 ceq parseModule2(M, '__[T, T']) = M''
  if M' := parseDef(M, T) /\
     M'' := parseModule2(M', T') .
 eq parseModule2(M, T) = parseDef(M, T) [owise] .

 op parseDef : Module Term -> Module .
 ceq parseDef(M, 'rigid`sort_['token[T]]) = M'
  if Srt := downQid(T) /\
     M' := addSorts(M, Srt) .
 ceq parseDef(M, 'nominal`pred_:__['token[T],T',T'']) = M''
  if Q := downQid(T) /\
     TyL := parseTypeList(M, T') /\
     M' := addOps(M, op Q : TyL -> 'Bool [metadata("nominal")] .) /\
     M'' := parseSen(M', T'') .
 eq parseDef(M, T) = M [owise print "owise"] . *** TODO!!!

 op parseSen : Module Term -> Module .
 eq parseSen(M, T) = M .

 op parseTypeList : Module Term -> TypeList .
 ceq parseTypeList(M, 'token[T]) = Q
  if Q := downQid(T) .
 eq parseTypeList(M, '_*_[TL]) = parseTypeList*(M, TL) .

 op parseTypeList* : Module TermList -> TypeList .
 eq parseTypeList*(M, empty) = nil .
 eq parseTypeList*(M, (T, TL)) = parseTypeList(M, T) parseTypeList*(M, TL) .

 op parseModule : String -> Module .
 ceq parseModule(S) = M
  if {T, Srt} := metaParse(GRAMMAR, tokenize(S), anyType) /\
     M := parseModule(T) [print T " - " Srt "\n" M] .

 op isLoadComm : String -> Bool .
 ceq isLoadComm(S) = true
  if 'load QIL := tokenize(S) .
 eq isLoadComm(S) = false [owise] .

 op isExitComm : String -> Bool .
 ceq isExitComm(S) = true
  if 'exit := tokenize(S) .
 eq isExitComm(S) = false [owise] .

 op parseLoadComm : String -> String .
 ceq parseLoadComm(S) = string(Q')
  if Q Q' QIL := tokenize(S) .
endfm

mod MTP is
 pr (MAYBE * (op maybe to null)){Oid} .
 pr COMMAND-PROCESSING .
 inc STD-STREAM .
 pr DATABASE .
 inc FILE .

 vars Text Original Read Source : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  DB : Database .

 *** Object and class definition
 op MTP : -> Cid .
 op mtp : -> Oid .

 *** Attributes
 op file:_ : Maybe{Oid} -> Attribute [ctor] .
 op db:_ : Database -> Attribute [ctor] .
 op out:_ : String -> Attribute [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] : gotLine(mtp, stdin, Text)
    < mtp : MTP | out: Read, db: DB, Attrs >
 => < mtp : MTP | out: Read, db: DB, Attrs >
    openFile(fileManager, mtp, Source, "r")
  if isLoadComm(Text) /\
     Source := parseLoadComm(Text) .

 rl [openedFile] : openedFile(mtp, fileManager, FHIn)
    < mtp : MTP | file: null, Attrs >
 => < mtp : MTP | file: FHIn, Attrs >
    getLine(FHIn, mtp) .

 rl [loadModule] : gotLine(mtp, FHIn, Text)
    < mtp : MTP | file: FHIn, out: Read, db: DB, Attrs >
 => if Text == ""
    then < mtp : MTP | file: FHIn, out: "", db: parseModule(Read), Attrs >
         closeFile(FHIn, mtp)
    else < mtp : MTP | file: FHIn, out: (Read + Text), db: DB, Attrs >
         getLine(FHIn, mtp)
    fi .

 rl [closedFile] : closedFile(mtp, FHIn)
    < mtp : MTP | file: FHIn, Attrs >
 => < mtp : MTP | file: null, Attrs >
    getLine(stdin, mtp, "MTP> ") .

 ***                         ***
 ***          EXIT           ***
 ***                         ***

 crl [exit] : gotLine(mtp, stdin, Text)
     < mtp : MTP | out: Read, db: DB, Attrs >
  => write(stdout, mtp, "Thanks for using MTP!\n")
  if isExitComm(Text) .

 ***                        ***
 ***          ERROR         ***
 ***                        ***

 crl [no-command] :
     gotLine(mtp, stdin, Text)
     < mtp : MTP | Attrs >
  => < mtp : MTP | Attrs >
     write(stdout, mtp, "The introduced command does not exit.\n")
  if not isExitComm(Text) /\
     not isLoadComm(Text) .

 ***                          ***
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(mtp, stdout)
    < mtp : MTP | Attrs >
 => < mtp : MTP | Attrs >
    getLine(stdin, mtp, "MTP> ") .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < mtp : MTP | file: null, out: "", db: empty >
    getLine(stdin, mtp, "MTP> ") .
endm

set print attribute on .

erew run .
