load aux_modules.maude
load file.maude

fmod MTP-SIGN is
 pr META-LEVEL .

 sorts @Spec@ @Sen@ @SenList@ @Token@ @Bubble@ @Arity@ @Def@ @DefSet@
       @NeTokenList@ @ModExp@ @ParameterDecl@ @ParameterDeclList@ .
 subsort @Sen@ < @SenList@ .
 subsort @Token@ < @Arity@ .
 subsort @Token@ < @ModExp@ .
 subsort @Def@ < @DefSet@ .
 subsort @ParameterDecl@ < @ParameterDeclList@ .

 op _,_ : @ParameterDeclList@ @ParameterDeclList@ -> @ParameterDeclList@ [ctor assoc] .

 op _{_} : @Token@ @ParameterDeclList@ -> @ModExp@ [ctor] .

 op _::_ : @Token@ @Token@ -> @ParameterDecl@ [ctor] .

 op __ : @SenList@ @SenList@ -> @SenList@ [ctor assoc] .
 op __ : @DefSet@ @DefSet@ -> @DefSet@ [ctor assoc comm] .

 op _*_ : @Arity@ @Arity@ -> @Arity@ [ctor assoc] .

 op spec!_=_ : @ModExp@ @DefSet@ -> @Spec@ [ctor] .
 op spec*_=_ : @ModExp@ @DefSet@ -> @Spec@ [ctor] .

 op rigid`sort_ : @Token@ -> @Def@ [ctor] .
 op nominal`pred_:__ : @Token@ @Arity@ @SenList@ -> @Def@ [ctor] .

 op ._ : @Token@ -> @Sen@ [ctor] .
endfm

fmod META-MTP-SIGN is
 including AUX-MODULE-OPS .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'MTP-SIGN .)) .
endfm

fmod COMMAND-SIGN is
 pr META-LEVEL .

 sort @Command@ @Token@ .

 op load_. : @Token@ -> @Command@ [ctor] .
endfm

fmod COMMAND-PROCESSING is
 pr PARSING-RESULT .
 pr META-MTP-SIGN .
 pr META-LEVEL .
 pr LEXICAL .

 vars PL PL' : ParameterDeclList .
 vars T T' T'' T1 T2 : Term .
 var  RP? : [ResultPair] .
 vars M M' M'' : Module .
 var  PR : ParsingRes .
 var  TyL : TypeList .
 var  DB : Database .
 var  TL : TermList .
 vars S S' : String .
 var  QIL : QidList .
 vars Q Q' : Qid .
 var  Srt : Sort .
 var  H : Header .

 op parseModule : Term Database -> ParsingRes .
 ceq parseModule('spec!_=_[T,T'], DB) = [ modName(H) -> [parseModule2(M, T'), parseModule2(M, T'), parseModule2(M, T')], ""]
  if H := parseHeader(T) /\
     M := emptyModule(H) .
 ceq parseModule('spec*_=_[T,T'], DB) = [ modName(H) -> [parseModule2(M, T'), parseModule2(M, T'), parseModule2(M, T')], ""]
  if H := parseHeader(T) /\
     M := emptyTheory(H) .

 op parseModule2 : Module Term -> Module .
 ceq parseModule2(M, '__[T, T']) = M''
  if M' := parseDef(M, T) /\
     M'' := parseModule2(M', T') .
 eq parseModule2(M, T) = parseDef(M, T) [owise] .

 op parseHeader : Term -> Header .
 ceq parseHeader('token[T]) = Q
  if Q := downQid(T) .
 ceq parseHeader('_`{_`}['token[T], T']) = Q{PL}
  if Q := downQid(T) /\
     PL := parsePL(T') .

 op modName : Header -> Qid .
 eq modName(Q) = Q .
 eq modName(Q{PL}) = Q .

 op parsePL : Term -> ParameterDeclList .
 ceq parsePL('_`,_[T, T']) = PL, PL'
  if PL := parsePL(T) /\
     PL' := parsePL(T') .
 ceq parsePL('_::_['token[T], 'token[T']]) = Q :: Q'
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op parseDef : Module Term -> Module .
 ceq parseDef(M, 'rigid`sort_['token[T]]) = M'
  if Srt := downQid(T) /\
     M' := addSorts(M, Srt) .
 ceq parseDef(M, 'nominal`pred_:__['token[T],T',T'']) = M''
  if Q := downQid(T) /\
     TyL := parseTypeList(M, T') /\
     M' := addOps(M, op Q : TyL -> 'Bool [metadata("nominal")] .) /\
     M'' := parseSen(M', T'') .
 eq parseDef(M, T) = M [owise print "owise"] . *** TODO!!!

 op parseSen : Module Term -> Module .
 eq parseSen(M, T) = M .

 op parseTypeList : Module Term -> TypeList .
 ceq parseTypeList(M, 'token[T]) = Q
  if Q := downQid(T) .
 eq parseTypeList(M, '_*_[TL]) = parseTypeList*(M, TL) .

 op parseTypeList* : Module TermList -> TypeList .
 eq parseTypeList*(M, empty) = nil .
 eq parseTypeList*(M, (T, TL)) = parseTypeList(M, T) parseTypeList*(M, TL) .

 op myDB : -> Database .

 op parseModule : String Database -> ParsingRes .
 ceq parseModule(S, DB) = PR
  if {T, Srt} := metaParse(GRAMMAR, tokenize(S), anyType) /\
     PR := parseModule(T, DB) [print T " - " Srt "\n" PR] .

 op isLoadComm : String -> Bool .
 ceq isLoadComm(S) = true
  if 'load QIL := tokenize(S) .
 eq isLoadComm(S) = false [owise] .

 op isExitComm : String -> Bool .
 ceq isExitComm(S) = true
  if 'exit := tokenize(S) .
 eq isExitComm(S) = false [owise] .

 op parseLoadComm : String -> String .
 ceq parseLoadComm(S) = string(Q')
  if Q Q' QIL := tokenize(S) .
endfm

mod MTP is
 pr (MAYBE * (op maybe to null)){Oid} .
 pr COMMAND-PROCESSING .
 inc STD-STREAM .
 pr DATABASE .
 inc FILE .

 vars Text Original Read Source STR : String .
 var  Attrs : AttributeSet .
 vars DB DB' : Database .
 vars FHIn FHOut : Oid .

 sort State .
 *** Waiting input from the user
 op idle : -> State [ctor] .
 *** Reading file
 op readFile : -> State [ctor] .
 *** Parsing Module
 op parseMod : -> State [ctor] .
 *** Waits for a wrote msg and returns to idle with getLine
 op print&idle : -> State [ctor] .

 *** Object and class definition
 op MTP : -> Cid .
 op mtp : -> Oid .

 *** Attributes
 op file:_ : Maybe{Oid} -> Attribute [ctor] .
 op db:_ : Database -> Attribute [ctor] .
 op out:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] : gotLine(mtp, stdin, Text)
    < mtp : MTP | out: Read, db: DB, state: idle, Attrs >
 => < mtp : MTP | out: Read, db: DB, state: readFile, Attrs >
    openFile(fileManager, mtp, Source, "r")
  if isLoadComm(Text) /\
     Source := parseLoadComm(Text) .

 ***                            ***
 ***          OPENFILE          ***
 ***                            ***

 rl [openedFile] : openedFile(mtp, fileManager, FHIn)
    < mtp : MTP | file: null, state: readFile, Attrs >
 => < mtp : MTP | file: FHIn, state: readFile, Attrs >
    getLine(FHIn, mtp) .

 rl [readingModule] : gotLine(mtp, FHIn, Text)
    < mtp : MTP | file: FHIn, out: Read, state: readFile, Attrs >
 => if Text == ""
    then < mtp : MTP | file: FHIn, out: Read, state: readFile, Attrs >
         closeFile(FHIn, mtp)
    else < mtp : MTP | file: FHIn, out: (Read + Text), state: readFile, Attrs >
         getLine(FHIn, mtp)
    fi .

 crl [parseModuleOK] :
     < mtp : MTP | out: Read, db: DB, state: parseMod, Attrs >
  => < mtp : MTP | out: "", db: DB', state: print&idle, Attrs >
     write(stdout, mtp, STR + "\n")
  if [DB', STR] := parseModule(Read, DB) .

 *** TODO: parse error

 rl [print&idle] : wrote(mtp, stdout)
    < mtp : MTP | state: print&idle, Attrs >
 => < mtp : MTP | state: idle, Attrs >
    getLine(stdin, mtp, "MTP> ") .

 ***                               ***
 ***          CLOSE FILE           ***
 ***                               ***

 rl [closedFile] : closedFile(mtp, FHIn)
    < mtp : MTP | file: FHIn, state: readFile, Attrs >
 => < mtp : MTP | file: null, state: parseMod, Attrs > .

 ***                         ***
 ***          EXIT           ***
 ***                         ***

 crl [exit] : gotLine(mtp, stdin, Text)
     < mtp : MTP | out: Read, db: DB, Attrs >
  => write(stdout, mtp, "Thanks for using MTP!\n")
  if isExitComm(Text) .

 ***                        ***
 ***          ERROR         ***
 ***                        ***

 crl [no-command] :
     gotLine(mtp, stdin, Text)
     < mtp : MTP | state: idle, Attrs >
  => < mtp : MTP | state: print&idle, Attrs >
     write(stdout, mtp, "The introduced command does not exit.\n")
  if not isExitComm(Text) /\
     not isLoadComm(Text) .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < mtp : MTP | file: null, out: "", state: idle, db: empty >
    getLine(stdin, mtp, "MTP> ") .
endm

set print attribute on .

erew run .
